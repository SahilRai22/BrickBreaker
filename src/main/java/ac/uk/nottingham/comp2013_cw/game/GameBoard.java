package ac.uk.nottingham.comp2013_cw.game;import ac.uk.nottingham.comp2013_cw.ball.Ball;import ac.uk.nottingham.comp2013_cw.brick.Brick;import ac.uk.nottingham.comp2013_cw.debug.DebugConsole;import javax.swing.*;import java.awt.*;import java.awt.event.*;import java.awt.font.FontRenderContext;import java.net.MalformedURLException;/** * @author - Sahil Rai - modified * <p> * This class listens to button and key pressed allowing user to control * the game screen. This class has been modified so the game screen colour * can be controlled in through main menu controller. */public class GameBoard extends JComponent implements KeyListener, MouseListener,        MouseMotionListener {    private static final String CONTINUE = "Continue";    private static final String RESTART = "Restart";    private static final String EXIT = "Exit";    private static final String PAUSE = "Pause Menu";    private static final int TEXT_SIZE = 30;    private static final Color MENU_COLOR = new Color(0, 255, 0);    /*Removed magic numbers for new constants*/    private static final int ADJUST_GET_HEIGHT = 10;    private static final int PAUSE_ADJUST_HEIGHT = 8 ;    private static final int PAUSE_ADJUST_WIDTH = 4;    private static final int CONTINUE_ADJUST_Y = 2;    private static final float RESTART_ADJUST_Y = 3.0F;    private static final int DEF_WIDTH = 600;    private static final int DEF_HEIGHT = 450;    /** Constant for colour picker*/    public static Color BG_COLOR = Color.WHITE;    /**Constant to divide integers*/    public static final int HALF = 2;    /** defines game timer object */    private Timer m_GameTimer;    /** defines wall object */    private final Wall m_Wall;    /** defines Score object*/    private final Score m_Score;    /** defines messages object */    private String m_Message;    /** defines pause menu object */    private boolean m_ShowMenu;    /** defines menu font object*/    private final Font m_MenuFont;    /** defines continue button */    private Rectangle m_ContinueButtonRect;    /** defines exit button */    private Rectangle m_ExitButtonRect;    /** defines restart button */    private Rectangle m_RestartButtonRect;    /** defines string length */    private int m_StrLen;    /** defines the debug console */    private final DebugConsole m_DebugConsole;    /**     * This method is responsible to generate contents in frame     * @param owner frame of owner     * */    public GameBoard(JFrame owner) {        super();        m_Score = new Score();        m_StrLen = 0;        m_ShowMenu = false;        m_MenuFont = new Font("Monospaced", Font.PLAIN, TEXT_SIZE);        this.initialize();        m_Score.scoreChecker();        m_Message = "Press SPACE to start";        m_Wall = new Wall(new Rectangle(0, 0, DEF_WIDTH, DEF_HEIGHT),                30, 3, 3, new Point(300,                430));        m_DebugConsole = new DebugConsole(owner, m_Wall, this);        m_Score.scoreChecker();        m_Score.getScoreReset();        m_Wall.getNextLevel();        m_GameTimer = new Timer(10, e -> {            m_Wall.Move();            try {                m_Wall.findImpacts();            } catch (MalformedURLException ex) {                ex.printStackTrace();            }            m_Message = String.format("Bricks: %d Balls %d Score: %d", m_Wall                            .getBrickCount(),                    m_Wall.getBallCount(), m_Score.getScoreCount());            if (m_Score.highScore.equals(null)) {                m_Score.highScore = m_Score.getHighScoreFile();            }            if (m_Wall.getBallLost()) {                if (m_Wall.getBallEnd()) {                    m_Wall.wallReset();                    m_Message = String.format("Game over!! Your score is: %d",                            m_Score.getScoreCount());                    m_Score.scoreChecker();                    m_Score.getScoreReset();                }                m_Wall.ballReset();                m_GameTimer.stop();            } else if (m_Wall.setDone()) {                if (m_Wall.getHasLevel()) {                    m_Message = String.format("Your score is: %d Go to Next Level",                            m_Score.getScoreCount());                    m_GameTimer.stop();                    m_Wall.ballReset();                    m_Wall.wallReset();                    // wall.scoreReset();                    m_Wall.getNextLevel();                } else {                    m_Message = "ALL WALLS DESTROYED";                    m_GameTimer.stop();                }            }            repaint();        });    }    /**     * This method is responsible to initialise key arguments in the class     * */    public void initialize() {        this.setPreferredSize(new Dimension(DEF_WIDTH, DEF_HEIGHT));        this.setFocusable(true);        this.requestFocusInWindow();        this.addKeyListener(this);        this.addMouseListener(this);        this.addMouseMotionListener(this);    }    public void paint(Graphics g) {        Graphics2D g2d = (Graphics2D) g;        clear(g2d);        g2d.setColor(Color.BLUE);        g2d.drawString(m_Message, 250, 225);        drawBall(m_Wall.ball, g2d);        if (m_Score.highScore.equals(null)) {            m_Score.highScore = m_Score.getHighScoreFile();        }        for (Brick b : m_Wall.bricks) {            if (!b.getIsBroken()) {                drawBrick(b, g2d);            }        }        drawPlayer(m_Wall.player, g2d);        if (m_ShowMenu)            drawMenu(g2d);        Toolkit.getDefaultToolkit().sync();    }    /**     * This method sets graphic colouring to be clear (0)     * @param g2d 2d graphics which gets filled with set colour     * */    public void clear(Graphics2D g2d) {        Color tmp = g2d.getColor();        g2d.setColor(BG_COLOR);        g2d.fillRect(0, 0, getWidth(), getHeight());        g2d.setColor(tmp);    }    /**     * This method is responsible to generate brick     * @param brick what features brick will have     * @param g2d which graphics is used for brick     * */    public void drawBrick(Brick brick, Graphics2D g2d) {        Color tmp = g2d.getColor();        g2d.setColor(brick.getInnerColor());        g2d.fill(brick.getBrick());        g2d.setColor(brick.getBorderColor());        g2d.draw(brick.getBrick());        g2d.setColor(tmp);    }    /**     * This method is responsible to generate a ball     * @param ball what features ball will have     * @param g2d which graphics is used for ball     * */    public void drawBall(Ball ball, Graphics2D g2d) {        Color tmp = g2d.getColor();        Shape s = ball.getBallFace();        g2d.setColor(ball.getInnerColor());        g2d.fill(s);        g2d.setColor(ball.getBorderColor());        g2d.draw(s);        g2d.setColor(tmp);    }    /**     * This method generates the player     * @param p the paddle player uses     * @param g2d what graphics is used for player paddle     * */    public void drawPlayer(Paddle p, Graphics2D g2d) {        Color tmp = g2d.getColor();        Shape s = p.getPaddleFace();        g2d.setColor(Paddle.INNER_COLOR);        g2d.fill(s);        g2d.setColor(Paddle.BORDER_COLOR);        g2d.draw(s);        g2d.setColor(tmp);    }    /**     * This method generates the menu     * @param g2d what graphics is used for menu     * */    public void drawMenu(Graphics2D g2d) {        obscureGameBoard(g2d);        drawPauseMenu(g2d);    }    /**     * This method generates the obscure menu     * @param g2d what graphics is used for obscure menu     * */    public void obscureGameBoard(Graphics2D g2d) {        Composite tmp = g2d.getComposite();        Color tmpColor = g2d.getColor();        AlphaComposite ac = AlphaComposite.getInstance(AlphaComposite.SRC_OVER,                0.55f);        g2d.setComposite(ac);        g2d.setColor(Color.BLACK);        g2d.fillRect(0, 0, DEF_WIDTH, DEF_HEIGHT);        g2d.setComposite(tmp);        g2d.setColor(tmpColor);    }    /** This method stops timer when focus lost */    public void onLostFocus() {        m_GameTimer.stop();        m_Message = "Focus Lost";        repaint();    }    /**     * This method generates the pause menu     * @param g2d what graphics is used for pause menu     * */    public void drawPauseMenu(Graphics2D g2d) {        Font tmpFont = g2d.getFont();        Color tmpColor = g2d.getColor();        g2d.setFont(m_MenuFont);        g2d.setColor(MENU_COLOR);        if (m_StrLen == 0) {            FontRenderContext frc = g2d.getFontRenderContext();            m_StrLen = m_MenuFont.getStringBounds(PAUSE, frc).getBounds().width;        }        int x = (this.getWidth() - m_StrLen) / HALF;        int y = this.getHeight() / ADJUST_GET_HEIGHT;        g2d.drawString(PAUSE, x, y);        x = this.getWidth() / PAUSE_ADJUST_HEIGHT;        y = this.getHeight() / PAUSE_ADJUST_WIDTH;        if (m_ContinueButtonRect == null) {            FontRenderContext frc = g2d.getFontRenderContext();            m_ContinueButtonRect = m_MenuFont.getStringBounds(CONTINUE, frc).getBounds();            m_ContinueButtonRect.setLocation(x, y - m_ContinueButtonRect.height);        }        g2d.drawString(CONTINUE, x, y);        y *= CONTINUE_ADJUST_Y;        if (m_RestartButtonRect == null) {            m_RestartButtonRect = (Rectangle) m_ContinueButtonRect.clone();            m_RestartButtonRect.setLocation(x, y - m_RestartButtonRect.height);        }        g2d.drawString(RESTART, x, y);        y *= RESTART_ADJUST_Y / HALF;        if (m_ExitButtonRect == null) {            m_ExitButtonRect = (Rectangle) m_ContinueButtonRect.clone();            m_ExitButtonRect.setLocation(x, y - m_ExitButtonRect.height);        }        g2d.drawString(EXIT, x, y);        g2d.setFont(tmpFont);        g2d.setColor(tmpColor);    }    @Override    public void keyTyped(KeyEvent keyEvent) {    }    @Override    public void keyPressed(KeyEvent e) {        int code = e.getKeyCode();        if (code == KeyEvent.VK_LEFT) {            m_Wall.player.moveLeft();        }        if (code == KeyEvent.VK_RIGHT) {            m_Wall.player.movRight();        }        if (code == KeyEvent.VK_SPACE) {            if (!m_ShowMenu)                if (m_GameTimer.isRunning())                    m_GameTimer.stop();                else                    m_GameTimer.start();        }        if (code == KeyEvent.VK_ESCAPE) {            m_ShowMenu = !m_ShowMenu;            repaint();            m_GameTimer.stop();        }        if (code == KeyEvent.VK_F1) {            if (e.isAltDown() && e.isShiftDown())                m_DebugConsole.setVisible(true);        }    }    @Override    public void keyReleased(KeyEvent keyEvent) {        m_Wall.player.stop();    }    @Override    public void mouseClicked(MouseEvent mouseEvent) {        Point p = mouseEvent.getPoint();        if (!m_ShowMenu)            return;        if (m_ContinueButtonRect.contains(p)) {            m_ShowMenu = false;            repaint();        } else if (m_RestartButtonRect.contains(p)) {            m_Message = "Restarting Game...";            m_Wall.ballReset();            m_Wall.wallReset();            Score.getScoreReset();            m_ShowMenu = false;            repaint();        } else if (m_ExitButtonRect.contains(p)) {            System.exit(0);        }    }    @Override    public void mousePressed(MouseEvent mouseEvent) {    }    @Override    public void mouseReleased(MouseEvent mouseEvent) {    }    @Override    public void mouseEntered(MouseEvent mouseEvent) {    }    @Override    public void mouseExited(MouseEvent mouseEvent) {    }    @Override    public void mouseDragged(MouseEvent mouseEvent) {    }    @Override    public void mouseMoved(MouseEvent mouseEvent) {        Point p = mouseEvent.getPoint();        if (m_ExitButtonRect != null && m_ShowMenu) {            if (m_ExitButtonRect.contains(p) || m_ContinueButtonRect.contains(p) ||                    m_RestartButtonRect.contains(p))                this.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));            else                this.setCursor(Cursor.getDefaultCursor());        } else {            this.setCursor(Cursor.getDefaultCursor());        }    }}